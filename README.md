## Подготовительная программа по программированию на C/C++.

## Домашнее задание № 6. Сетевой калькулятор

В рамках домашнего задания вам предлагается реализовать полноценное клиент-серверное приложение на C++, которое будет принимать задачи от клиентов на матричные операции и выполнять их в асинхронном режиме.

## Поддерживаемые операции:

### 1) умножение матрицы на скаляр
формат входных данных: \
cA \
10 \
3 5 \
1 2 3 4 5 \
2 3 4 5 6 \
3 4 5 6 7

формат выходных данных \
3 5 \
10 20 30 40 50 \
20 30 40 50 60 \
30 40 50 60 70

### 2) сложение матриц
формат входных данных: \
A+B \
3 5 \
1 2 3 4 5 \
2 3 4 5 6 \
3 4 5 6 7 \
3 5 \
7 6 5 4 3 \
8 7 6 5 4 \
9 8 7 6 5

формат выходных данных \
3 5 \
8 8 8 8 8 \
10 10 10 10 10 \
12 12 12 12 12

### 3) вычитание матриц
формат входных данных: \
A-B \
3 5 \
1 2 3 4 5 \
2 3 4 5 6 \
3 4 5 6 7 \
3 5 \
9 8 7 6 5 \
8 7 6 5 4 \
7 6 5 4 3

формат выходных данных \
3 5 \
-8 -6 -4 -2 0 \
-6 -4 -2 0 2 \
-4 -2 0 2 4

### 4) умножение матриц
формат входных данных: \
AxB \
3 5 \
1 2 3 4 5 \
2 3 4 5 6 \
3 4 5 6 7 \
5 3 \
9 8 7 \
6 5 4 \
3 2 1 \
0 1 2 \
3 4 5

формат выходных данных \
3 3 \
45 48 51 \
66 68 70 \
87 88 89

### 5) транспонирование матрицы
формат входных данных: \
AT \
3 5 \
1 2 3 4 5 \
2 3 4 5 6 \
3 4 5 6 7

формат выходных данных \
5 3 \
1 2 3 \
2 3 4 \
3 4 5 \
4 5 6 \
5 6 7

### 6) подсчёт определителя матрицы
формат входных данных: \
detA \
5 5 \
1 2 3 4 5 \
5 4 3 2 1 \
1 4 5 7 9 \
9 7 5 2 1 \
2 4 6 8 9

формат выходных данных \
12

### 7) подсчёт обратной матрицы
формат входных данных: \
invA \
3 3 \
1 3 5 \
3 5 1 \
2 4 6

формат выходных данных \
3 3 \
-2.16666667 -0.16666667 1.83333333 \
1.33333333 0.33333333 -1.16666667 \
-0.16666667 -0.16666667 0.33333333 \

При возникновении любой ошибки (деление на ноль, несоответствие размерности, некорректные данные) - в качестве результата выполнения операции необходимо сохранить ERROR (Response{Type=Error, content=""}).

## Описание основных сущностей

Основных активных сущностей 2 - это клиент и сервер. Однако внутри сервера, в свою очередь, присутствуют ещё три разные группы процессов, осуществляющих логику его работы:
- сервер (основной процесс сервера) - поднимает сервер на заданном порту и принимает соединения (accept)
- net-воркеры - процессы, создаваемые основным серверным процессом, каждый из которых занимается взаимодействием по сети с клиентом
- планировщик - процесс-планировщик, создаётся сервером в самом начале работы, управляет очередью и задач и их распределением между task-воркерами
- task-воркеры - процессы, порождаемые планировщиком (он порождает целый пул процессов ограниченного размера, причём пополняет его лениво, т.е. в том случае, когда задача на выполнение есть, но все существующие воркеры заняты) и выполняющие основные задачи бизнес-логики серверного приложения (матричные операции)

## Механизм работы сервера

1) Запускается первая программа-сервер. Она принимает 3 аргумента командной строки:
- порт, на котором нужно запустить сервер (по умолчанию, 8080)
- путь до рабочей директории, которая может быть использована для хранения временных файлов (по умолчанию, /tmp)
- максимальное количество task-воркеров

2) Запускаются клиенты (каждый клиент - отдельная программа, но может запуститься последовательно несколько клиентов из одной програмы, как в тестах), которые отправляют задачи на сервер и получают результаты работы.

3) После запуска сервер сразу создаёт отдельный процесс-планировщик и pipe "server->planner", задача которого - хранить общую очередь задач и распределять её между task-воркерами. После создания процесс-планировщик переходит в состояние ожидания новых задач, а основной процесс - в состояние ожидания новых подключений.

4) При появлении нового клиента:
- сервер порождает net-воркер и передаёт ему client_fd, а также pipe "synchro (server->net)", через который сообщит net-воркеру о готовности передачи данных, полученных от клиента, процессу planner
- сервер создаёт пару named-pipe (mkfifo) для связи между net-воркером и планировщиком (named-pipe-to-net-{pid} и named-pipe-from-net-{pid}). Имя named-pipe однозначно идентифицируется по pid net-воркера
- сервер уведомляет net-воркера через pipe "synchro" о создании named-pipe
- сервер передаёт через pipe "server->planner" pid net-воркера
- сервер продолжает ожидать новых соединений
- net-воркер в это время считывает данные из сетевого сокета клиента client_fd
- net-воркер после получения уведомления через pipe "synchro" пишет в named-pipe "from-net" данные, полученные от клиента
- net-воркер ожидает результатов обработки полученных данных из named-pipe "to-net"
- после получения данных - отправляет их по сети клиенту через client_fd

5) Планировщик в цикле проверяет наличие сообщений от основного серверного процесса (pipe "server->planner"), и от уже запущенных task-воркеров. Хранит очередь задач (task_id -> status), добавляет новые в конец, а также умеет быстро находить задачу по task_id. При наличии задач в статусе New (статус новой задачи в очереди, готовой к обработке таск-воркером), пытается её передать запросившим воркерам. Если никто ничего не запросил, но есть нераспределённые задачи, а размер пула таск-воркеров не достиг максимального - создаёт нового таск-воркера

6) Жизненный цикл процесса-планировщика следующий:
- при создании от основного процесса-планировщика он получает pipe, через который может взаимодействовать с сервером
- при создании дочерних процессов-обработчиков он также создаёт отдельные pipe (to_worker и from_worker), через которые обменивается с ними статусами задач
- в вечном цикле процесс-планировщик проверяет все pipe, которые настроены в неблокирующем режиме, на наличие новых сообщений. Если никаких сообщений не найдено, то он засыпает на 100 мс (чтобы не тратить процессорное время в вечном цикле - это касается и всех других процессов!)
- при получении сообщения от какого-либо pipe, он приступает к обработке. Это либо добавление новой задачи в очередь, либо изменение её статуса и удаление из очереди.

7) Каждый task-воркер имеет следующий жизненный цикл:
- порождение процессом-планировщиком сервера
- запрос (GET) новой задачи через pipe с процессом-планировщиком (после этого задача переводится планировщиком в состояние WORK)
- если это задача типа Receive (на обработку новых данных клиента) - десериализация данных, полученных из named_pipe "from-net", проверка корректности заголовка запроса (Get/Post), запрос у планировщика уникального id (планировщик выделяет новый id, но не проставляет задаче статус New - ставит Unknown, т.к. всё ещё возможна ошибка при сохранении данных таск-воркером), таск-воркер сохраняет данные клиента в файле task-{task_id}, обновляет статус задачи через планировщик на New и возвращает через named_pipe "to-net" task_id и её статус New (Response{Type=New, content=task_id})
- если это задача типа Process (на выполнение уже сохранённой ранее задачи), то task-воркер читает из файла данные по задаче и пытается выполнить полезную логику (в базовой версии - она уже написана (Matrix::Process), и там выполняется случайная задержка, в extra - её нужно реализовать по аналогии с предыдущими ДЗ)
- сохранение в тот же файл результата работы (в формате, описанном выше)
- сообщение через pipe процессу-планировщику о статусе выполнения задачи (ERROR/DONE)
- запрос новой задачи ...

8) все операции чтения из дескрипторов (сокетов/сетевых) должны быть неблокирующими + во время ожидания должна быть возможность остановить процесс по SIGINT => в цикле ожидания нужно проверять флаг "running", который может поменяться в обработке сигнала SIGINT

9) завершение работы сервера осуществляется следующим образом:
- посылается сигнал SIGINT основному процессу сервера (ctrl+c)
- он посылает сигнал SIGINT процессу-планировщику и net-воркерам
- net-воркеры удаляют named-pipe-ы, которые больше не нужны, и корректно закрывает соединение с клиентом
- процесс-планировщик посылает сигнал SIGINT каждому из своих дочерних task-воркеров
- после завершения всех дочерних процессов-обработчиков, процесс-планировщик удаляет все временные файлы с задачами (task-*), которые обрабатывались или находились в очереди
- после завершения всех процессов, основной серверный процесс завершает свою работу
- все процессы должны успешно освободить все ресурсы и успешно завершить свою работу. Неуспешное завершение хотя бы одного процесса должно приводить к неуспешному завершению всего сервера в целом (что проверяется тестами)

10) при возникновении любых ошибок (пропажа сети/ошибка файловой системы/...) нужно вернуть ошибку, закрыть дескрипторы для связи с другими основными процессами, и по аналогии с SIGINT проконтролировать корректное завершение всех серверных процессов

## Формат клиент-серверного взаимодействия

Клиент присоединяется по TCP к порту сервера, который был указан при запуске сервера. Посылает ему пакеты с задачами, имеющими следующий формат:
<Заголовок><Тело>

Заголовок содержит:
- тип запроса - POST/GET. POST - отправка новой задачи. GET - получение статуса (и результата, если готов) задачи

Тело содержит полезную информацию:
- в случае POST-запроса - данные с видом матричной операции и матрицами в формате входных данных, который был описан выше
- в случае GET-запроса - id задачи, полученной ранее от сервера

Сервер возвращает клиенту такие же пакеты, однако вместо типа запроса отправляет тип ответа:
- NEW - задача создана, в теле указывается id задачи
- WORK - задача в работе, в теле указывается id задачи
- ERROR - при выполнении задачи возникла ошибка, в теле указывается id задачи
- DONE - задача выполнена, в теле указываются данные из файла-результата в формате выходных данных, который был описан выше

После ответа клиенту любого статуса по задаче из ERROR/DONE процесс-планировщик удаляет задачу из очереди и удаляет соответствующий файл на жёстком диске.

Общая схема работы клиента:
```cpp
auto connect_status = Client.ConnectTo(EndPoint{...});
auto [error_status, Response] = Client.SendRequest(Request{...});
```

Типы запросов (Request::Type):
- kGet - получение статуса задачи (и ответа) по id
- kPost - публикация новой задачи (с ожиданием созданного id или Error (Response{Type=Error, content=""}))
(есть kUnknown + структура запросов может быть некорректной - см. примеры в тестах)

Типы ответов (Response::Type):
- kNew - сервер создал новую задачу (content: id)
- kWork - таск-воркер выполняет задачу (content: id)
- kError - при выполнении задачи возникла ошибка: формат/ошибка при выполнении операции/... (content: id)
- kDone - результат выполнения операции (в базовой версии - то же сообщение, что и было отправлено, если оно не начинается с Error, в extra-версии - content: полученный результат в соответствии с форматом, описанным в начале)

Типы задач, получаемых таск-воркером (WorkerTask::Type):
- kReceive - сохранение данных от пользователя, в int id -> pid net-воркера (TaggedId::kNet)
- kProcess - обработка ранее сохранённой задачи, в int id -> task_id Задачи (TaggedId::kTaskId)

Типы запросов, отправляемых от таск-ворверов планировщику (UpdateQueueRequest::Type):
- kCreate - запрос нового уникального id задачи (планировщик вправе создать задачу Process и добавить её в очередь, но не с New, а со статусом Unknown)
- kNew    - перевод задачи с task_id в статус New
- kGet    - получение новой New-задачи из очереди (с её переводом в Work)
- kCheck  - получение статуса задачи с task_id. Если статус Done/Error - удалить из очереди
- kDone   - перевод задачи с task_id в статус Done
- kError  - перевод задачи с task_id в статус Error
- kDelete - удаление задачи с task_id (например, может использоваться после kCreate, но при неудаче создания файла)

На каждый UpdateQueueRequest, планировщик отправляет таск-воркеру UpdateQueueResponse для подтверждения (и синхронизации) операции. Где данные не оговорены (например, при переводе задачи в тот или иной статус) - можно возвращать актуальный статус задачи

## Инфраструктура

Предлагается начать разработку с наладки сетевого взаимодействия между клиентом и сервером, для чего могут помочь main() в client.cpp (до отправки запросов) и server.cpp. Только после отладки базовых сценариев на client.cpp и server.cpp, можно приступать к тестам в test_client.cpp
В Makefile предусмотрены следующие таргеты (build/run):
- сервер (отладочная версия сервера, должна иметь свой main под DEBUG-флагом и успешно собираться)
- клиент (отладочная версия клиента, должна иметь свой main под DEBUG-флагом и успешно собираться)
- тест-клиент - все основные тесты, запускает в несколько потоков много разных запросов (можно играться с константами под ifdef, но при отправке они должны быть исходными)
- тест-сервер (особо ничем не отличается от сервера, менять нельзя)
- extra-тест-клиент - версия тест-клиента, в которой отключены echo-заглушки (по умолчанию, не компилируется)
- extra-тест-сервер - версия тест-сервера, в которой отключены echo-заглушки (по умолчанию, не компилируется)
- check - проверка стиля
- memtest - проверка valgrind (в итоговом файле склеиваются отчёты для всех воркеров)

## Пара слов о каркасе

Кода много - он получен "удалением" участков, отвечающих за взаимодействие между процессами, работу с файловыми дескрипторами и сетью.
Менять интерфейс можно, если что-то использоваться не будет (но всё будет работать с теми тестами, что есть) - ничего страшного нет. Если что-то совсем использоваться не будет, то лучше это убрать перед отправкой на ревью.
Можно использовать `const char *` вместо `std::vector<std::byte>` или свои реализации тех или иных контейнеров. Можно убрать вообще весь код заготовки и написать всё "с нуля", а на исходный код ориентироваться лишь как на каркас. Но если познакомитесь с STL-контейнерами и современными возможностями языка C++ - хуже от этого точно не будет :)
Единственное, что менять нельзя - это код тестов!

## Критерии оценивания
За эту задачу можно получить **до 3 баллов**. Задание сложное, стоит приступить к нему как можно раньше!

- +1 балл за работу базовой части (реализация эхо-сервера + тестирование минимальной функциональности на малой нагрузке);
- +1 балл за работу extra-части (без memtest - реализация логики обработки матричных операций + тестирование на большой нагрузке и с большим числом таск-воркеров);
- +1 балл за полное прохождение всех проверок на CI.

Ну и как всегда, код должен быть оформлен "хорошо" - соблюдайте стиль, разбивайте логику на отдельные подфункции и т.д. Если какие-то из заготовок вам в итоге не понадобились, можете смело их удалить - неиспользуемого кода тоже остаться не должно.

## Напутствие

Желаю вам получить искреннее удовольствие от выполнения домашнего задания!
Дорогу осилит идущий!
